<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Third-Person Game</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: skyblue;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL2 is not supported by your browser!');
            throw new Error('WebGL2 is required to run this application.');
        }

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Vertex shader
        const vertexShaderSource = `#version 300 es
        precision mediump float;

        layout(location = 0) in vec3 position;
        uniform mat4 projectionMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 modelMatrix;

        void main() {
            gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
        }
        `;

        // Fragment shader
        const fragmentShaderSource = `#version 300 es
        precision mediump float;

        out vec4 fragColor;
        uniform vec4 color;

        void main() {
            fragColor = color;
        }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }

            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        gl.useProgram(program);

        // Define a cube for the player
        const cubeVertices = new Float32Array([
            -0.5, -0.5, -0.5,  // Back face
             0.5, -0.5, -0.5,
             0.5,  0.5, -0.5,
            -0.5,  0.5, -0.5,
            -0.5, -0.5,  0.5,  // Front face
             0.5, -0.5,  0.5,
             0.5,  0.5,  0.5,
            -0.5,  0.5,  0.5
        ]);

        const cubeIndices = new Uint16Array([
            0, 1, 2,  2, 3, 0,  // Back
            4, 5, 6,  6, 7, 4,  // Front
            0, 1, 5,  5, 4, 0,  // Bottom
            2, 3, 7,  7, 6, 2,  // Top
            0, 3, 7,  7, 4, 0,  // Left
            1, 2, 6,  6, 5, 1   // Right
        ]);

        const vao = gl.createVertexArray();
        const vbo = gl.createBuffer();
        const ebo = gl.createBuffer();

        gl.bindVertexArray(vao);

        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

        const positionAttribLocation = gl.getAttribLocation(program, 'position');
        gl.vertexAttribPointer(positionAttribLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionAttribLocation);

        // Matrices and locations
        const projectionMatrixLocation = gl.getUniformLocation(program, 'projectionMatrix');
        const viewMatrixLocation = gl.getUniformLocation(program, 'viewMatrix');
        const modelMatrixLocation = gl.getUniformLocation(program, 'modelMatrix');
        const colorLocation = gl.getUniformLocation(program, 'color');

        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);

        const viewMatrix = mat4.create();
        mat4.translate(viewMatrix, viewMatrix, [0, -1, -5]);

        const modelMatrix = mat4.create();

        // Camera control variables
        let angleY = 0;
        let angleX = 0;

        window.addEventListener('keydown', (e) => {
            const rotationSpeed = 0.05;
            if (e.key === 'ArrowLeft') angleY -= rotationSpeed;
            if (e.key === 'ArrowRight') angleY += rotationSpeed;
            if (e.key === 'ArrowUp') angleX -= rotationSpeed;
            if (e.key === 'ArrowDown') angleX += rotationSpeed;
        });

        function updateViewMatrix() {
            mat4.identity(viewMatrix);
            mat4.translate(viewMatrix, viewMatrix, [0, -1, -5]);
            mat4.rotateY(viewMatrix, viewMatrix, angleY);
            mat4.rotateX(viewMatrix, viewMatrix, angleX);
        }

        function render() {
            gl.clearColor(0.53, 0.81, 0.92, 1.0); // Sky blue
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            updateViewMatrix();

            gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);
            gl.uniformMatrix4fv(viewMatrixLocation, false, viewMatrix);

            // Draw player cube
            mat4.identity(modelMatrix);
            gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);
            gl.uniform4f(colorLocation, 1.0, 0.0, 0.0, 1.0); // Red color
            gl.bindVertexArray(vao);
            gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }

        render();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@2.8.1/dist/gl-matrix-min.js"></script>
</body>
</html>
